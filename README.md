# boost_python_compile_notes
My travels with building Boost.Python


Objective:  Build Boost.Python on Ubuntu Linux against an existing, specific conda environment that is using Python3.11.  This is in complete disregard for any default Python installation that may be on your machine, and it also does not require you to sudo apt install anything.

Steps: 
1.  Download boost.  As of this writing:  boost_1_82_0.tar.gz
2.  tar -xzvf boost_1_82_0.tar.gz
3.  sudo mv boost_1_82_0 /usr/local/boost

Decide which python environment you want to build against.  In this case, I want to build against my conda xxx environment, which uses Python 3.11.

4.  Find these files within the specified conda environment, and record their paths:  
    libpython3.11.so :       ~/miniconda3/envs/xxx/lib/libpython3.11.so
    
    Python.h    :            ~/miniconda3/envs/xxx/include/python3.11/Python.h
    
    python3.11 executable   :     ~/miniconda3/envs/xxx/bin/python3.11
    
5.  Create a directory to hold all your freshly-built Boost Python stuff:
```bash
mkdir ~/3Boost
```

### Prepare your bootstrap.sh arguments (adjust all paths for your own environment):
```bash
./bootstrap.sh --with-python=/home/rl/miniconda3/envs/xxx/bin/python3.11 --with-python-root=/home/rl/miniconda3/envs/xxx --with-python-version=3.11 --with-libraries=python --with-icu --with-icu=/home/rl/miniconda3/envs/xxx/lib --prefix=/home/rl/3Boost --exec-prefix=/home/rl/3Boost --libdir=/home/rl/3Boost/lib --includedir=/home/rl/3Boost/include

// bootstrap overwrites your project-config.jam.  But a lot of the arguments I passed to bootstrap were to build the project-config.jam pile properly.  nevertheless, always cat project-config.jam to assert that it contains what you need it to contain.
```

#### NOTE:  

Don't shortcut paths with ~/ for home, like I've done in my notes.  In any command or config, write out the full path: /home/rl/whatever/and_more/...

When you run bootstrap, it will backup but also write over any work you may have done to project-config.jam.  If you already made the changes below to project-config.jam, it will likely now be renamed project-config.jam.1.  Or some other number.  In all regards, at this point, you must make sure that the file, project-config.jam is the file with your paths and notes.  You know what to do....  

Location:  project-config.jam:  /usr/local/boost/project-config.jam

#### project-config.jam file contents:
```bash

cat project-config.jam
# B2 Configuration
# Automatically generated by bootstrap.sh, but we make changes below before running ./b2 ....

import option ;
import feature ;

# Compiler configuration. This definition will be used unless
# you already have defined some toolsets in your user-config.jam
# file.
if ! gcc in [ feature.values <toolset> ]
{
    using gcc ; 
}

project : default-build <toolset>gcc ;

# Python configuration  (I hard-coded my home/rl path.  Shortcutting with ~/ does not work.  Fix path to suit your proper /home/whatever/ path.
import python ;
if ! [ python.configured ]
{
    using python 
    : 3.11 
    : /home/rl/miniconda3/envs/xxx/bin/python3.11
    : /home/rl/miniconda3/envs/xxx/include/python3.11
    : /home/rl/miniconda3/envs/xxx/lib
    ;
}

path-constant ICU_PATH : /usr ;


# List of --with-<library> and --without-<library>
# options. If left empty, all libraries will be built.
# Options specified on the command line completely
# override this variable.
libraries = python ;

# These settings are equivalent to corresponding command-line
# options.
option.set prefix : /home/rl/3Boost ;
option.set exec-prefix : /home/rl/3Boost ;
option.set libdir : /home/rl/3Boost/lib ;
option.set includedir : /home/rl/3Boost/include ;

# Stop on first error
option.set keep-going : false ;
##### END of file 
```

### Run ./b2 --help.  Then, once ready, run your own b2 with your own arguments:
```bash
cd /usr/local/boost
./b2 --with-python --prefix=/home/rl/3Boost  --stagedir=/home/rl/3Boost/stage  stage --build-type=complete  --build-dir=/home/rl/3Boost-build --layout=versioned --variant=release --link=shared threading=single,multi runtime-link=static,shared
```
I recommend adding this to the tail of the b2 command:  > /home/rl/3Boost/b2_output.txt
You can read that file to look for any errors in the build.  

Boost.Python .so files will now be ready for use in your c++ library build:

###  the super-important makefile:
command:  make -f makefile_name.mak

File Contents:
```
PYTHON_VERSION = 3.11
PYTHON_INCLUDE = /home/rl/miniconda3/envs/xxx/include/python3.11

BOOST_INC = /usr/local/boost
BOOST_LIB = /home/rl/3Boost/stage/lib/

# compile mesh class
TARGET = calc_dist
SOURCES = calc_dist.cpp options.cpp
O_FILES = calc_dist.o options.o

# all commands on the 2nd line must be TAB-INDENTED
$(TARGET).so: $(O_FILES)
	g++ -shared -Wl,-rpath=/home/rl/3Boost/stage/lib -Wall -export-dynamic $(O_FILES) -L$(BOOST_LIB) -lboost_python311-gcc11-x64-1_82 -L/usr/lib/python3.11/config-3.11-x86_64-linux-gnu -lpython$(PYTHON_VERSION) -o $(TARGET).so

calc_dist.o: calc_dist.cpp
	g++ -I$(PYTHON_INCLUDE) -I$(BOOST_INC) -fPIC -c calc_dist.cpp

options.o: options.cpp
	g++ -I$(PYTHON_INCLUDE) -I$(BOOST_INC) -fPIC -c options.cpp

clean:
	rm -f *.o *.so

```

Note the use of rpath in the makefile build command.  This is critical to do.  In your python script, when you import calc_dist (or your own library name), the import will fail with an error message indicating it can't find one of the more arcane files in your Boost.Python .so files.  Using rpath in your build of your own .so library fixes this.


Finally, don't ask me.  I'm not a Boost expert.  I was just struggling through the Boost.Python build process like most everyone, and documented my navigation of the process here, mostly for me, the next time I find myself needing to do this again.


